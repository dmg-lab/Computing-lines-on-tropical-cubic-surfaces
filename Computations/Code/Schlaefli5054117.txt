
loadPackage "Polyhedra"

--- Points Configuration
PC = matrix{{0,0,0},{0,0,1},{0,0,2},{0,0,3},{0,1,0},{0,1,1},{0,1,2},{0,2,0},{0,2,1},{0,3,0},{1,0,0},{1,0,1},{1,0,2},{1,1,0},{1,1,1},{1,2,0},{2,0,0},{2,0,1},{2,1,0},{3,0,0}}

--- Ring
R = QQ[x,y,z,a,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19]

--- Tropical monomials
FF = {c0,c1+z,c2+2*z,c3+3*z,c4+y,c5+y+z,c6+y+2*z,c7+2*y,c8+2*y+z,c9+3*y,c10+x,c11+x+z,c12+x+2*z,c13+x+y,c14+x+y+z,c15+x+2*y,c16+2*x,c17+2*x+z,c18+2*x+y,c19+3*x}

--- Rays directions
Dirs = matrix{{-1,-1,-1},{1,0,0},{0,1,0},{0,0,1}}

--- Coefficients 
Vars = transpose (vars R)_{4..23}
Lvars = flatten entries Vars

--- Variables
X = matrix{{x},{y},{z}}

MotA = {{{18, 17, 15, 11, 2, 9},{0, 2, 3, 1}},{{18, 19, 15, 11, 2, 9},{3, 2, 0, 1}},{{18, 19, 15, 11, 2, 9},{0, 2, 3, 1}},{{18, 17, 15, 11, 1, 9},{0, 2, 3, 1}},{{18, 19, 15, 11, 1, 9},{3, 2, 0, 1}},{{18, 19, 15, 11, 1, 9},{0, 2, 3, 1}}}
MotB = {{{9, 15, 7, 1, 18, 19},{0, 1, 2, 3}},{{17, 18, 11, 1, 15, 7},{0, 2, 1, 3}},{{17, 18, 11, 1, 15, 9},{0, 2, 1, 3}},{{19, 18, 11, 1, 15, 7},{0, 2, 1, 3}},{{19, 18, 11, 1, 15, 9},{0, 2, 1, 3}}}
MotD = {{{3, 14, 2, 11, 1, 9, 15},{1, 0, 2, 3}},{{9, 15, 2, 11, 1, 9, 15},{1, 0, 2, 3}},{{14, 15, 2, 11, 1, 9, 15},{1, 0, 2, 3}},{{3, 14, 2, 11, 1, 15, 18},{1, 0, 2, 3}},{{9, 15, 2, 11, 1, 15, 18},{1, 0, 2, 3}},{{14, 15, 2, 11, 1, 15, 18},{1, 0, 2, 3}},{{3, 14, 2, 11, 1, 18, 19},{1, 0, 2, 3}},{{9, 15, 2, 11, 1, 18, 19},{1, 0, 2, 3}},{{14, 15, 2, 11, 1, 18, 19},{1, 0, 2, 3}},{{9, 15, 1, 11, 2, 3, 14},{1, 3, 2, 0}},{{15, 18, 1, 11, 2, 3, 14},{1, 3, 2, 0}},{{18, 19, 1, 11, 2, 3, 14},{1, 3, 2, 0}},{{9, 15, 1, 11, 2, 9, 15},{1, 3, 2, 0}},{{15, 18, 1, 11, 2, 9, 15},{1, 3, 2, 0}},{{18, 19, 1, 11, 2, 9, 15},{1, 3, 2, 0}},{{9, 15, 1, 11, 2, 14, 15},{1, 3, 2, 0}},{{15, 18, 1, 11, 2, 14, 15},{1, 3, 2, 0}},{{18, 19, 1, 11, 2, 14, 15},{1, 3, 2, 0}},{{2, 3, 14, 11, 17, 15, 18},{0, 1, 2, 3}},{{1, 9, 15, 11, 17, 15, 18},{0, 1, 2, 3}},{{2, 9, 15, 11, 17, 15, 18},{0, 1, 2, 3}},{{2, 3, 14, 11, 17, 18, 19},{0, 1, 2, 3}},{{1, 9, 15, 11, 17, 18, 19},{0, 1, 2, 3}},{{2, 9, 15, 11, 17, 18, 19},{0, 1, 2, 3}}}
MotH = {{{7, 15, 1, 18, 19},{0, 1, 2, 3}},{{9, 15, 2, 14, 3},{1, 3, 2, 0}},{{18, 19, 1, 13, 4},{0, 2, 1, 3}},{{11, 18, 1, 15, 9},{0, 2, 1, 3}},{{18, 19, 1, 13, 7},{0, 2, 1, 3}},{{9, 11, 1, 15, 7},{0, 2, 1, 3}},{{11, 18, 1, 15, 7},{0, 2, 1, 3}}}
MotJ = {{{11, 9, 15, 1, 2},{0, 3, 1, 2}}}



coef = matrix{{1/8},{-3/4},{-13/96},{41/48},{-3/32},{-1/8},{17/24},{0},{5/8},{55/96},{1/32},{-5/8},{19/48},{-1/16},{1/8},{3/32},{0},{0},{0},{0}}



SC = {c0-2*c10 + c16,c1 + c2 - 3*c5 + c9,c4 - 2*c13 +c18,c10 - 2*c16 +c19,-c4 +c13 +c16 -c19,c5 - c9 - c11 + c15,-c1 + c7 + c11 - c15, -c7 + c13 + c15 - c18, c7 - c13 - c18 + c19,c3 - 2*c6 + c8,c2 -c3 - c11 + c12,c6 - 2*c8 +c9,c8 - c9 - c14 + c15,-c2 + c9 + c11 + c14 - 2*c15,c3 - 2*c12 + c17,c14 - c15 - c17 + c18}


Sec = matrix apply(SC, f->apply(Lvars, v -> coefficient(v, f)))
SecCone = coneFromHData Sec
rays SecCone
FSecCone = facets SecCone



---Method to compute vertices of lines dual to occurrences of motif A. 
verticesA = method()
verticesA (List) := (Mot)-> (
 	  Mpts = matrix apply(Mot_0, e -> flatten entries PC^{e});	---points appearing in the motif
	  Mcoef = matrix apply(Mot_0, e-> flatten entries Vars^{e});   ----coefficients  appearing in the motif
	  
	  M1 = matrix{{Mpts^{2}-Mpts^{3}},{Mpts^{3}-Mpts^{4}},{Mpts^{4}-Mpts^{5}}};  ---system to compute the vertex CDEF
	  N1 = matrix{{Mcoef^{3}-Mcoef^{2}},{Mcoef^{4}-Mcoef^{3}},{Mcoef^{5}-Mcoef^{4}}};
	  VerCDEF = inverse(M1)*N1;  ---vertex dual to tetrahedron CDEF
	  
	  Ray = VerCDEF - a* promote(transpose Dirs^{Mot_1_3},R);  ---ray in direction j passing through VerCDEF
	  M2 =  matrix{{Mpts^{0}-Mpts^{2}},{Mpts^{2}-Mpts^{3}}};  ---system to compute the edge ACD 
	  N2 = matrix{{Mcoef^{2}-Mcoef^{0}},{Mcoef^{3}-Mcoef^{2}}};
      ---we want to interset Ray with edge ACD 
	  Sys2=M2*Ray-N2;
	  if not Sys2^{0} == 0 then eqn2 = Sys2^{0} else eqn2 = Sys2^{1};
	  if coefficient(a,eqn2_(0,0)) == 1 then val = -eqn2_(0,0) + a else val = eqn2_(0,0) + a;  ---solving for a
	  VerACD = sub(Ray,{a=>val});  ---substituting the value for a in Ray to get the vertex of the line on edge ACD
	  
	  Edge = VerACD +a*promote(transpose Dirs^{Mot_1_0}+transpose Dirs^{Mot_1_1},R);  ---edge of the  line in direction i+j
	  M3 =  matrix{{Mpts^{0}-Mpts^{1}},{Mpts^{1}-Mpts^{3}}};  ---system to compute the edge ABD 
	  N3 = matrix{{Mcoef^{1}-Mcoef^{0}},{Mcoef^{3}-Mcoef^{1}}};
	   ---we want to intersect Edge with edge ABD
	  Sys3=M3*Edge-N3;
	  if not Sys3^{0} == 0 then eqn3 = Sys3^{0} else eqn3 = Sys3^{1};
	  if coefficient(a,eqn3_(0,0)) == 1 then val = -eqn3_(0,0)+a else val = eqn3_(0,0)+a; ---solving for a 
	  VerABD = sub(Edge,{a=>val});  ---substituting the value for a in Edge to get the vertex of the line on edge ABD
	  (VerABD, VerACD)
)



--- method to compute Schlaefli inequalities of occurrences of motif A. Input: Motif. Output: Linear form in the ci's.
SchlaefliA = method()
SchlaefliA (List) := (Mot) -> (
	  V1 = (verticesA(Mot))_0;
	  V2 = (verticesA(Mot))_1;
	  fst = Mot_0_0;
	  Hyp1 =  apply(FF, f->sub(f, {x=>V1_(0,0), y=>V1_(1,0), z=>V1_(2,0)}));
	  Hyp2 = apply(FF, f->sub(f, {x=>V2_(0,0), y=>V2_(1,0), z=>V2_(2,0)}));---substitue coordinates vertex 2 in tropical polynomial
	  q1 = Hyp1_fst;
	  q2 = Hyp2_fst;
	  Ineq1 =  apply(Hyp1, f->(f- q1));---condition minimum achieved at monomials A,B,D
	  Ineq2 = apply(Hyp2, f->(f- q2));
	  Totineq = Ineq1|Ineq2;
 	  IM = matrix apply(Totineq, f->apply(Lvars, v -> coefficient(v, f)));
	  C = coneFromInequalities IM;
  	  Inters =  intersection(C,SecCone);
	  Finter = facets Inters;
	  row = numgens target Finter-1;
	  rowSC = numgens target FSecCone -1;
	  Pls = hyperplanes Inters;
	  Plform = Pls;
          ind = select(toList(0..row), i -> not any(toList(0..rowSC), j -> Finter^{i} == FSecCone^{j}));---find facets of the intersection which are not facets of secondary cone
          lform = Finter^ind;
	  << lform << endl;
	  << Plform << endl;
)


--- Method to compute vertices of lines dual to occurrences of  motif B. 
verticesB = method()
verticesB (List) := (Mot) -> (
	  Mpts = matrix apply(Mot_0, e -> flatten entries PC^{e});   ---points appearing in the motif
	  Mcoef = matrix apply(Mot_0, e-> flatten entries Vars^{e});   ---coefficients  appearing in the motif
 	  
	  M1 = matrix{{Mpts^{1}-Mpts^{2}},{Mpts^{2}-Mpts^{3}},{Mpts^{3}-Mpts^{4}}};  ---system to compute vertex dual to BCDE
	  N1 = matrix{{Mcoef^{2}-Mcoef^{1}},{Mcoef^{3}-Mcoef^{2}},{Mcoef^{4}-Mcoef^{3}}};
	  VerBCDE = inverse(M1)*N1;  ---coordinates vertex dual to tetrahedron BCDE
	  
	  EdgeR = VerBCDE -a* promote(transpose Dirs^{Mot_1_0}+ transpose Dirs^{Mot_1_1},R);  ---edges starting at vertex BCDE in directions i+j 
	  EdgeL = VerBCDE +a* promote(transpose Dirs^{Mot_1_0}+ transpose Dirs^{Mot_1_1},R);
	  
	  M2 =  matrix{{Mpts^{0}-Mpts^{1}},{Mpts^{1}-Mpts^{2}}};  ---system to compute edge ABC
	  N2 = matrix{{Mcoef^{1}-Mcoef^{0}},{Mcoef^{2}-Mcoef^{1}}};  
      Sys2=M2*EdgeL-N2;
	  if not Sys2^{0} == 0 then eqn2 = Sys2^{0} else eqn2 = Sys2^{1};
	  if coefficient(a,eqn2_(0,0)) == 1 then val = -eqn2_(0,0) + a else val = eqn2_(0,0) + a;  ---solving for a
	  VerABC = sub(EdgeL,{a=>val});  ---substituting value of a in EdgeL to get the vertex of the line on the edge ABC
	  
 	  M3 =  matrix{{Mpts^{3}-Mpts^{4}},{Mpts^{4}-Mpts^{5}}};  ---system to compute edge DEF
	  N3 = matrix{{Mcoef^{4}-Mcoef^{3}},{Mcoef^{5}-Mcoef^{4}}};
	  Sys3=M3*EdgeR-N3;
	  if not Sys3^{0} == 0 then eqn3 = Sys3^{0} else eqn3 = Sys3^{1};
	  if coefficient(a,eqn3_(0,0)) == 1 then val = -eqn3_(0,0)+a else val = eqn3_(0,0)+a;  ---solving for a
	  VerDEF = sub(EdgeR,{a=>val});	---substituting value of a in EdgeR to get the vertex of the line on the edge DEF
	  (VerABC,VerDEF)
)



---method to compute Schlaefli inequalities of occurrences of motif B. Input: Motif. Output: Linear form in the ci's.
SchlaefliB = method()
SchlaefliB (List) := (Mot) -> (
	  V1 = (verticesB(Mot))_0;
	  V2 = (verticesB(Mot))_1;
	  fst1 = Mot_0_0;
	  fst2 = Mot_0_3;
	  Hyp1 =  apply(FF, f->sub(f, {x=>V1_(0,0), y=>V1_(1,0), z=>V1_(2,0)}));
	  Hyp2 = apply(FF, f->sub(f, {x=>V2_(0,0), y=>V2_(1,0), z=>V2_(2,0)}));---substitue coordinates vertex 2 in tropical polynomial
	  q1 = Hyp1_fst1;
	  q2 = Hyp2_fst2;
	  Ineq1 =  apply(Hyp1, f->(f- q1));---condition minimum achieved at monomials A,B,D
	  Ineq2 = apply(Hyp2, f->(f- q2));
	  Totineq = Ineq1|Ineq2;
 	  IM = matrix apply(Totineq, f->apply(Lvars, v -> coefficient(v, f)));
	  C = coneFromInequalities IM;
  	  Inters =  intersection(C,SecCone);
	  Finter = facets Inters;
	  row = numgens target Finter-1;
	  rowSC = numgens target FSecCone -1;
	  Pls = hyperplanes Inters;
	  Plform = Pls * Vars;
	  ind = select(toList(0..row), i -> not any(toList(0..rowSC), j -> Finter^{i} == FSecCone^{j}));---find facets of the intersection which are not facets of secondary cone
          lform = Finter^ind;
	  << Mot << endl;
	  << lform << endl;
	  << Plform << endl;
)


 ---method to compute vertices of lines dual to occurrnces of motif D. 
verticesD = method()
verticesD (List) := (Mot) -> (
	  Mpts = matrix apply(Mot_0, e -> flatten entries PC^{e});   ----points appearing in the motif
	  Mcoef = matrix apply(Mot_0, e-> flatten entries Vars^{e});   ----coefficients appearing in the motif
	  
	  M1 = matrix{{Mpts^{0}-Mpts^{1}},{Mpts^{1}-Mpts^{2}},{Mpts^{2}-Mpts^{3}}};  ---system to compute the vertex ABCD
	  N1 = matrix{{Mcoef^{1}-Mcoef^{0}},{Mcoef^{2}-Mcoef^{1}},{Mcoef^{3}-Mcoef^{2}}};
	  VerABCD = inverse(M1)*N1;  ----vertex dual to tetrahedron ABCD
	  
	  Ray1 = VerABCD - a*promote(transpose Dirs^{Mot_1_1},R); --- Ray in direction j through vertex ABCD
	  M2 =  matrix{{Mpts^{2}-Mpts^{3}},{Mpts^{3}-Mpts^{4}}};  ---system to compute edge CDE
	  N2 = matrix{{Mcoef^{3}-Mcoef^{2}},{Mcoef^{4}-Mcoef^{3}}};
	  Sys2=M2*Ray1-N2;
	  if not Sys2^{0} == 0 then eqn2 = Sys2^{0} else eqn2 = Sys2^{1};
	  if coefficient(a,eqn2_(0,0)) == 1 then val = -eqn2_(0,0) + a else val = eqn2_(0,0) + a;  ---solving for a 
	  VerCDE = sub(Ray1,{a=>val}); --- substituting value of a in Ray1 to get vertex of line on edge CDE
	  
	  M3 = matrix{{Mpts^{3}-Mpts^{4}},{Mpts^{4}-Mpts^{5}},{Mpts^{5}-Mpts^{6}}};  ---system to compute vertex DEFG
	  N3 = matrix{{Mcoef^{4}-Mcoef^{3}},{Mcoef^{5}-Mcoef^{4}},{Mcoef^{6}-Mcoef^{5}}};
	  VerDEFG = inverse(M3)*N3;  ---vertex dual to tetrahedron DEFG
	  Ray2=VerDEFG -a*promote(transpose Dirs^{Mot_1_3},R);  ---ray in direction l through vertex DEFG
	  
	  A = transpose matrix{{promote(Dirs^{Mot_1_0}+Dirs^{Mot_1_1},R)}, {promote(Dirs^{Mot_1_3},R)}};  ---compute intersection of Ray2 with Edge in direction i+j from vertex on CDE 
	  B = VerDEFG-VerCDE;
	  m= first select({{0,1},{0,2},{1,2}}, i -> det A^i !=0);
	  Y  = inverse( A^m)*B^m;
	  Ver2 = sub(Ray2,{a=>Y_(1,0)});
	  (VerCDE,Ver2)
)


 ---method to compute Schlaefli inequalities of occurrences of motif D. Input: Motif. Output: Linear form in the ci's.
SchlaefliD = method()
SchlaefliD (List) := (Mot) -> (
	  V1 = (verticesD(Mot))_0;
	  V2 = (verticesD(Mot))_1;
	  fst1 = Mot_0_2;
	  fst2 = Mot_0_3;
	  Hyp1 =  apply(FF, f->sub(f, {x=>V1_(0,0), y=>V1_(1,0), z=>V1_(2,0)}));
	  Hyp2 = apply(FF, f->sub(f, {x=>V2_(0,0), y=>V2_(1,0), z=>V2_(2,0)}));---substitue coordinates vertex 2 in tropical polynomial
	  q1 = Hyp1_fst1;
	  q2 = Hyp2_fst2;
	  Ineq1 =  apply(Hyp1, f->(f- q1));---condition minimum achieved at monomials A,B,D
	  Ineq2 = apply(Hyp2, f->(f- q2));
	  Totineq = Ineq1|Ineq2;
 	  IM = matrix apply(Totineq, f->apply(Lvars, v -> coefficient(v, f)));
	  C = coneFromInequalities IM;
  	  Inters =  intersection(C,SecCone);
	  Finter = facets Inters;
	  row = numgens target Finter-1;
	  rowSC = numgens target FSecCone -1;
	  Pls = hyperplanes Inters;
	  Plform = Pls * Vars;
          ind = select(toList(0..row), i -> not any(toList(0..rowSC), j -> Finter^{i} == FSecCone^{j}));---find facets of the intersection which are not facets of secondary cone
          lform = Finter^ind;
	  << Mot << endl;
	  << lform << endl;
	  << Plform << endl;
)


 ---method to compute vertices of lines dual to occurrences of motif H
verticesH = method()
verticesH (List) := (Mot) -> (
	  Mpts = matrix apply(Mot_0, e -> flatten entries PC^{e});   ---points appearing in the motif
	  Mcoef = matrix apply(Mot_0, e-> flatten entries Vars^{e});   ---coefficients  appearing in the motif
	  Vcoef = matrix apply(Mot_0, e-> flatten entries coef^{e});
	  
	  M1 = matrix{{Mpts^{0}-Mpts^{1}},{Mpts^{1}-Mpts^{2}},{Mpts^{2}-Mpts^{3}}};  ---system to compute the vertex ABCD
	  N1 = matrix{{Mcoef^{1}-Mcoef^{0}},{Mcoef^{2}-Mcoef^{1}},{Mcoef^{3}-Mcoef^{2}}};
	  O1 = matrix{{Vcoef^{1}-Vcoef^{0}},{Vcoef^{2}-Vcoef^{1}},{Vcoef^{3}-Vcoef^{2}}};
	  VerABCD = inverse(M1)*N1;  ---vertex dual to tetrahedron ABCD
	  VVerABCD = inverse(M1)*O1;
	  
	  EdgeR = VerABCD +a*promote(transpose Dirs^{Mot_1_0}+ transpose Dirs^{Mot_1_1},R);  ---Edge in direction i+j from vertex ABCD
	  M2 =  matrix{{Mpts^{2}-Mpts^{3}},{Mpts^{3}-Mpts^{4}}};  ---system to compute edge CDE
	  N2 = matrix{{Mcoef^{3}-Mcoef^{2}},{Mcoef^{4}-Mcoef^{3}}};
	  Sys2=M2*EdgeR-N2;
	  if not Sys2^{0} == 0 then eqn2 = Sys2^{0} else eqn2 = Sys2^{1};
	  if coefficient(a,eqn2_(0,0)) == 1 then val = -eqn2_(0,0) + a else val = eqn2_(0,0) + a;  ---solving for a
	  VerCDE = sub(EdgeR,{a=>val});  ---substituting value of a in Ray1 to get vertex of line on edge CDE
	  (VerABCD,VerCDE)
	   
)


 ---method to compute Schlaefli inequalities of occurrences of  motif H. Input: Motif. Output: Linear form in the ci's.
SchlaefliH = method()
SchlaefliH (List) := (Mot) -> (
	  V1 = (verticesH(Mot))_0;
	  V2 = (verticesH(Mot))_1;
	  fst = Mot_0_4;
	  Hyp1 = apply(FF, f->sub(f, {x=>V2_(0,0), y=>V2_(1,0), z=>V2_(2,0)}));  ---substitue coordinates vertex 2 in tropical polynomial
	  q = Hyp1_fst;
	  Ineq1 =  apply(Hyp1, f->(f- q));  ---condition minimum achieved at monomials C,D,E
	  Totineq = Ineq1;
 	  IM = matrix apply(Totineq, f->apply(Lvars, v -> coefficient(v, f)));
	  indNZ = select(toList(0..19), i -> IM^{i} != 0);
	  NZ = IM^indNZ;
	  C = coneFromInequalities NZ;
  	  Inters =  intersection(C,SecCone);
	  Finter = facets Inters;
	  row = numgens target Finter-1;
	  rowSC = numgens target FSecCone -1;
	  Pls = hyperplanes Inters;
	  Plform = Pls * Vars;
	  ind = select(toList(0..row), i -> not any(toList(0..rowSC), j -> Finter^{i} == FSecCone^{j}));  ---find facets of the intersection which are not facets of secondary cone
          lform = Finter^ind * Vars;
	  << Mot << endl;
	  << lform << endl;
	  << Plform << endl;
)


 ---method to compute vertices of lines dual to occurrences of motif J. 
verticesJ = method()
verticesJ (List) := (Mot)-> (
 	  Mpts = matrix apply(Mot_0, e -> flatten entries PC^{e});   ---points appearing in the motif
	  Mcoef = matrix apply(Mot_0, e-> flatten entries Vars^{e});   ---coefficients  appearing in the motif
	  
	  M1 = matrix{{Mpts^{0}-Mpts^{1}},{Mpts^{1}-Mpts^{2}},{Mpts^{2}-Mpts^{3}}};  ---system to compute the vertex ABCD
	  N1 = matrix{{Mcoef^{1}-Mcoef^{0}},{Mcoef^{2}-Mcoef^{1}},{Mcoef^{3}-Mcoef^{2}}};
	  VerABCD = inverse(M1)*N1;  ---vertex dual to tetrahedron ABCD
	  
	  M2 = matrix{{Mpts^{0}-Mpts^{1}},{Mpts^{1}-Mpts^{2}},{Mpts^{2}-Mpts^{4}}};  ---system to compute the vertex ABCE
	  N2 = matrix{{Mcoef^{1}-Mcoef^{0}},{Mcoef^{2}-Mcoef^{1}},{Mcoef^{4}-Mcoef^{2}}};
	  VerABCE = inverse(M2)*N2;  ---vertex dual to tetrahedron ABCD

	  Ray1 = VerABCD - a* promote(transpose Dirs^{Mot_1_1},R);  ---ray in direction j passing through VerABCD
	  Ray2 = VerABCE - a* promote(transpose Dirs^{Mot_1_0},R);  ---ray in direction j passing through VerABCD
	  M3 =  matrix{{Mpts^{0}-Mpts^{3}},{Mpts^{3}-Mpts^{4}}};  ---system to compute the edge ADE
	  N3 = matrix{{Mcoef^{3}-Mcoef^{0}},{Mcoef^{4}-Mcoef^{3}}};
          --- we want to interset Ray1 with edge ADE
	  Sys1=M3*Ray1-N3;
	  if not Sys1^{0} == 0 then eqn1 = Sys1^{0} else eqn1 = Sys1^{1};
	  if coefficient(a,eqn1_(0,0)) == 1 then val = -eqn1_(0,0) + a else val = eqn1_(0,0) + a;  ---solving for a
	  Ver1 = sub(Ray1,{a=>val});  ---substituting the value for a in Ray to get the vertex of the line on edge ACD
	  Sys2=M3*Ray2-N3;
	  if not Sys2^{0} == 0 then eqn2 = Sys2^{0} else eqn2 = Sys2^{1};
	  if coefficient(a,eqn2_(0,0)) == 1 then val = -eqn2_(0,0) + a else val = eqn2_(0,0) + a;  ---solving for a
	  Ver2 = sub(Ray2,{a=>val});  ---substituting the value for a in Ray to get the vertex of the line on edge ACD
	  Ver1
)



 ---method to compute Schlaefli inequalities of occurrences od motif J. Input: Motif. Output: Linear form in the ci's.
SchlaefliJ = method()
SchlaefliJ (List) := (Mot) -> (
	  V1 = verticesJ(Mot);
	  fst = Mot_0_0;
	  Hyp1 =  apply(FF, f->sub(f, {x=>V1_(0,0), y=>V1_(1,0), z=>V1_(2,0)}));
	  q1 = Hyp1_fst;
	  Ineq1 =  apply(Hyp1, f->(f- q1));  ---condition minimum achieved at monomials A,B,D
	  Totineq = Ineq1;
 	  IM = matrix apply(Totineq, f->apply(Lvars, v -> coefficient(v, f)));
	  C = coneFromInequalities IM;
  	  Inters =  intersection(C,SecCone);
	  Finter = facets Inters;
	  row = numgens target Finter-1;
	  rowSC = numgens target FSecCone -1;
	  Pls = hyperplanes Inters;
	  Plform = Pls;
          ind = select(toList(0..row), i -> not any(toList(0..rowSC), j -> Finter^{i} == FSecCone^{j}));  ---find facets of the intersection which are not facets of secondary cone
          lform = Finter^ind;
	  << Mot << endl;
	  << lform << endl;
	  << Plform << endl;
)

for Mot in MotA do SchlaefliA(Mot);
for Mot in MotB do SchlaefliB(Mot);
for Mot in MotD do SchlaefliD(Mot);
for Mot in MotH do SchlaefliH(Mot);
for Mot in MotJ do SchlaefliJ(Mot);
